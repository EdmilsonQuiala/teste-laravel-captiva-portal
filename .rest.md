Ambiente: macOS com Internet Sharing ativo.

PF configurado com anchor captive (funcionando).

Regra de rdr em bridge100 redireciona todo HTTP (80) dos clientes 192.168.2.0/24 para 127.0.0.1:8000.

Clientes não autenticados: HTTPS bloqueado; HTTP cai no portal.

Objetivo: ao logar (usuário/senha), adicionar o IP do cliente na tabela PF <allowed> (via script com sudo), liberando a Internet para esse IP.

Importante: a app Laravel roda no mesmo Mac que o PF.

1) Requisitos de implementação

Rota GET /: página de login simples (usuário/senha).

Rota POST /authorize: valida credenciais; se OK, executa script sudo /usr/local/bin/captive-allow.sh <IP_CLIENTE>; retorna “acesso liberado” e instruções para navegar.

Capturar IP real do cliente via $request->ip() (o cliente está diretamente no mesmo segmento / sem proxy).

Desabilitar CSRF só para /authorize (captive portal pode não manter cookies adequadamente no mini browser do SO).

Executar comando privilegiado com segurança:

Usar Symfony Process (não shell_exec) com paths absolutos.

Tratar timeouts, exit code, stdout/stderr.

Logs detalhados em storage/logs/laravel.log (tentativas, IP, saída do processo).

Arquivo de script /usr/local/bin/captive-allow.sh e sudoers corretos:

/etc/sudoers.d/captive com NOPASSWD para o usuário que executa o PHP.

Permitir /usr/bin/sudo, /usr/local/bin/captive-allow.sh, /sbin/pfctl, /usr/bin/tee.

2) Estrutura e Código (entregar pronto)
2.1 Rotas

routes/web.php

use Illuminate\Support\Facades\Route;
use App\Http\Controllers\CaptiveController;

Route::middleware('web')->group(function () {
    Route::get('/', [CaptiveController::class, 'showLogin'])->name('captive.login');
    Route::post('/authorize', [CaptiveController::class, 'authorizeClient'])->name('captive.authorize');
});

2.2 Controller

app/Http/Controllers/CaptiveController.php

<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use App\Services\CaptiveService;

class CaptiveController extends Controller
{
    public function showLogin()
    {
        // Página mínima: HTML inline para o CNA (mini browser do SO)
        return response()->view('captive.login');
    }

    public function authorizeClient(Request $request, CaptiveService $svc)
    {
        $request->validate([
            'username' => 'required|string',
            'password' => 'required|string',
        ]);

        // TODO: troque por validação real (DB/Users/etc.)
        $ok = $request->input('username') === 'admin' && $request->input('password') === '123456';

        $clientIp = $request->ip(); // ex.: 192.168.2.X
        Log::info('[CAPTIVE] tentativa de login', ['ip' => $clientIp, 'user' => $request->input('username')]);

        if (!$ok) {
            Log::warning('[CAPTIVE] credenciais inválidas', ['ip' => $clientIp]);
            return response('<h3>Credenciais inválidas</h3><a href="/">Tentar novamente</a>', 401);
        }

        $result = $svc->allowIp($clientIp);

        if (!$result['ok']) {
            Log::error('[CAPTIVE] falha ao liberar IP no PF', ['ip' => $clientIp, 'err' => $result['err'], 'out' => $result['out'], 'code' => $result['code']]);
            return response('<h3>Erro ao liberar acesso. Contate o suporte.</h3><pre>'.e($result['err']).'</pre>', 500);
        }

        Log::info('[CAPTIVE] IP liberado com sucesso', ['ip' => $clientIp, 'out' => $result['out']]);

        // Mensagem curta para CNA + link para testar navegação
        return response(
            "<h3>Acesso liberado para {$clientIp}</h3>".
            "<p>Você já pode navegar. Abra <a href=''>example.com</a> ou <a href=''>neverssl.com</a>.</p>"
        );
    }
}

2.3 Service (usa Symfony Process)

app/Services/CaptiveService.php

<?php

namespace App\Services;

use Illuminate\Support\Facades\Log;
use Symfony\Component\Process\Process;

class CaptiveService
{
    public function allowIp(string $ip): array
    {
        $script = '/usr/local/bin/captive-allow.sh';
        $sudo   = '/usr/bin/sudo';

        // Importante: caminhos absolutos e sem shell parsing
        $process = new Process([$sudo, $script, $ip]);
        $process->setTimeout(5); // segundos

        try {
            $process->run();
        } catch (\Throwable $e) {
            return ['ok' => false, 'code' => 1, 'out' => '', 'err' => $e->getMessage()];
        }

        $ok = $process->isSuccessful();
        return [
            'ok'   => $ok,
            'code' => $process->getExitCode(),
            'out'  => $process->getOutput(),
            'err'  => $process->getErrorOutput(),
        ];
    }
}

2.4 View simples

resources/views/captive/login.blade.php

<!doctype html>
<html lang="pt-br"><meta charset="utf-8">
<title>Portal de Acesso</title>
<body style="font-family:system-ui;max-width:420px;margin:40px auto">
  <h3>Portal de Acesso</h3>
  <form method="POST" action="/authorize">
    @csrf
    <input name="username" placeholder="Usuário" style="width:100%;padding:10px;margin:6px 0">
    <input type="password" name="password" placeholder="Senha" style="width:100%;padding:10px;margin:6px 0">
    <button style="padding:10px 16px">Entrar</button>
    <p style="color:#666">Após autenticar, o seu dispositivo terá acesso à Internet.</p>
  </form>
</body>
</html>

2.5 Desabilitar CSRF só para /authorize

app/Http/Middleware/VerifyCsrfToken.php

protected $except = [
    '/authorize',
];


Motivo: mini-browser de captive (iOS/Android) pode não manter cookies. Em produção, avalie reforçar com token customizado.

3) Script e sudoers (sistema)
3.1 Script de liberação

/usr/local/bin/captive-allow.sh

#!/bin/sh
IP="$1"

# Arquivo de persistência lido pelo PF
LIST="/etc/pf.captive.allowed"

# Adiciona IP ao arquivo se ainda não existir (linha exata)
if ! grep -qx "$IP" "$LIST" 2>/dev/null; then
  echo "$IP" | /usr/bin/sudo /usr/bin/tee -a "$LIST" >/dev/null
fi

# Adiciona IP na tabela "allowed" em runtime
/sbin/pfctl -t allowed -T add "$IP"

# Mostra o IP se estiver na tabela
/sbin/pfctl -t allowed -T show | /usr/bin/grep "$IP" || true


Permissões:

sudo chmod +x /usr/local/bin/captive-allow.sh
sudo touch /etc/pf.captive.allowed
sudo chmod 644 /etc/pf.captive.allowed

3.2 Sudoers (sem senha)
sudo visudo -f /etc/sudoers.d/captive


Conteúdo (trocar SEU_USUARIO pelo usuário que executa o PHP; se usar php artisan serve, é o seu usuário de login):

SEU_USUARIO ALL=(root) NOPASSWD: /usr/local/bin/captive-allow.sh, /sbin/pfctl, /usr/bin/tee


Dicas:

Use paths absolutos.

Se aparecer “sudo: no tty present and no askpass program specified”, é porque faltou NOPASSWD ou o usuário está errado.

Verifique qual usuário roda o PHP (no php artisan serve é o seu; em Apache/Nginx pode ser www-data, _www, etc.).

4) Regras PF relevantes (já existentes, conferir)

/etc/pf.anchors/captive (apenas trechos essenciais)

lan_if = "bridge100"
wan_if = "en0"
lan_net = "192.168.2.0/24"
portal_ip = "192.168.2.1"
portal_port = "8000"

table <allowed> persist file "/etc/pf.captive.allowed"

# REDIRECT HTTP -> Portal
rdr pass on $lan_if inet proto tcp from $lan_net to any port = 80 -> 127.0.0.1 port $portal_port

# Permissões locais e DNS
pass quick on lo0
pass quick on $lan_if proto { tcp, udp } from $lan_net to $portal_ip
pass quick on $lan_if proto udp from $lan_net to any port 53

# Bloqueio por padrão na saída
block drop quick on $wan_if from $lan_net to any

# Libera quem está na tabela <allowed>
pass quick on $wan_if from <allowed> to any keep state


Recarregar e checar:

sudo pfctl -f /etc/pf.conf
sudo pfctl -a captive -sn     # ver rdr
sudo pfctl -a captive -sr     # ver block/pass
sudo pfctl -t allowed -T show # ver tabela


5) Testes de Aceitação (passo-a-passo)

Cenário não autenticado

<allowed> vazio (sudo pfctl -t allowed -T flush e zere arquivo).

No celular: https://google.com
 → deve falhar.

http://neverssl.com
 → deve abrir o portal.

Login com admin / 123456

Envia POST para /authorize.

Esperado: 200 OK, mensagem “acesso liberado”.

No Mac: sudo pfctl -t allowed -T show → IP do celular listado.

Navegação liberada

No celular: https://google.com
 → agora funciona.

HTTP também funciona (sem redirecionar mais).

Logs

tail -f storage/logs/laravel.log deve mostrar tentativa, sucesso e saída do processo.

6) Erros comuns & Diagnóstico

“sudo: no tty present and no askpass program specified”
→ Corrigir /etc/sudoers.d/captive (usuário certo + NOPASSWD) e usar paths absolutos.

Tabela <allowed> não existe
→ Garanta a linha table <allowed> persist file "/etc/pf.captive.allowed" e rode sudo pfctl -f /etc/pf.conf.

Laravel não consegue executar o script

Verifique se proc_open/exec não estão desabilitados no php.ini.

Teste manual: sudo /usr/local/bin/captive-allow.sh 192.168.2.50 e veja se entra em pfctl -t allowed -T show.

Redirecionamento não ocorre
→ Certifique lan_if = "bridge100" (não bridge0), e que o cliente recebeu IP 192.168.2.x.

7) (Opcional) Logout/Expiração

Criar rota /logout que remove o IP da tabela e do arquivo:

// Exemplo rápido
$ip = $request->ip();
exec('/usr/bin/sudo /sbin/pfctl -t allowed -T delete ' . escapeshellarg($ip));
exec('/usr/bin/sudo /usr/bin/sed -i "" "/^'.preg_quote($ip,'/').'$/d" /etc/pf.captive.allowed');


(Opcional) armazenar ip + expires_at em DB e ter um Command cronado que revoga após X minutos.

8) Entregáveis que o agente deve devolver

Arquivos/Linhas alteradas:

routes/web.php

app/Http/Controllers/CaptiveController.php

app/Services/CaptiveService.php

resources/views/captive/login.blade.php

app/Http/Middleware/VerifyCsrfToken.php (exceção)

/usr/local/bin/captive-allow.sh (bash)

/etc/sudoers.d/captive (instruções de criação)

Comandos de verificação prontos (pfctl, tail logs).

Guia de teste final (como nos itens 5.1–5.4).